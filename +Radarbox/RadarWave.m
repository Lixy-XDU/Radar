classdef RadarWave 
    %WAVE 这是一个产生雷达波形的类
    %   产生LFM、FMCW信号，可分别调用LFM_Wave、FMCW子类实现所需功能。
    %   调用Wave_Delay方法实现回波延迟。
    %   
    properties
        f0  % 起始频率
        f_end   % 终止频率
        t1  % 起始时间
        t2  % 结束时间
        fs  % 时间轴采样率
        t   % 时间轴
        sigwave % 信号波形
        beta_v  (1,1)  % 多普勒系数
        wavetype
    end
    
    
    % 不要在意这个
    properties (Access = public)
        % fig_number = 1      % 绘图编号
        f_ax    % 频率轴
    end

    methods
        function obj = RadarWave(f0,f_end,t1,t2,fs)
            %WAVE 构造此类的实例
            %   此处显示详细说明
            arguments
                f0 (1,1) {mustBeNumeric}
                f_end (1,1) {mustBeNumeric}
                t1 (1,1) {mustBeNumeric}
                t2 (1,1) {mustBeNumeric}
                fs (1,1) {mustBeNumeric}
            end
            obj.f0 = f0;
            obj.f_end = f_end;
            obj.t1 = t1;
            obj.t2 = t2;
            obj.fs = fs;
            obj.t = Wave_set_timeline(obj);
            % obj.f_ax = Frequency_Domain(obj);
        end
        
        function timeline = Wave_set_timeline(obj)
            %Wave_set_timeline 生成时间轴
            %   此处显示详细说明
            timeline = obj.t1:1/obj.fs:obj.t2-1/obj.fs;
        end

        function sig_Delay = Wave_Delay(obj,td)
            arguments
                obj (1,1) {mustBeA(obj,'Radarbox.RadarWave')} 
                td  (1,1) {mustBeNumeric}
            end
            N = ceil(td * obj.fs);    % 延时采样点数
            phi = (N - td*obj.fs) * 2 * pi;
            sig = obj.sigwave * exp(1j*phi);
            sig_Delay = [zeros(1,N),sig(1:end-N)];
        end
        
        function obj = Wave_Doppler(obj,vr)
            %Wave_Doppler
            %   Calculate the echoes generated by the Doppler effect.
            arguments
                obj (1,1) {mustBeA(obj,'Radarbox.RadarWave')} 
                vr  (1,1) {mustBeNumeric} = 0
            end
            obj.beta_v = 1 + vr/1.5e8;
        end

        function Exvector = Wave_cycle_extension(~,N,vector,step,phi)
            %Wave_cycle_extension
            %   Return a cycle extension vector with a specific step.
            len = length(vector);
            Exvector = zeros(1,N*len);
            for i = 1:N
                Exvector(1+(i-1)*len:i*len) = vector*exp(-(i-1)*1j*phi) + (i-1)*step;
            end
        end

        % function obj = Rebuild(obj,vr)
        %     arguments
        %         obj (1,1) {mustBeA(obj,'Radarbox.RadarWave')}
        %         vr  (1,1) {mustBeNumeric} = 0
        %     end
        %     obj = obj.Wave_Doppler(vr);
        %     obj.f_ax = obj.beta_v*obj.f_ax;
        % end
        % 
        function obj = Wave_Rebuild(obj,vr)
            obj.beta_v = 1 + vr/1.5e8;
            switch obj.wavetype
                case Radarbox.Type.WaveType.LFM
                    obj = Radarbox.LFM_Wave.LFM_Rebuild(obj);
                case Radarbox.Type.WaveType.FMCW
                    obj = Radarbox.FMCW_Wave.FMCW_Rebuild(obj);
            end
        end
        % function sr = Wave_receive(obj,R0)
        %     %
        %     td = R0/1.5e8;
        %     sig_Delay = (1/R0)^4*obj.Wave_Delay;
        %     sr = sig_Delay.*exp(1j*2*pi*obj.f0*td);
        % end
    end
    methods (Access = protected)
        function obj = Frequency_Domain(obj,n_ax)
            % 要在子类里对属性f_ax初始化
            step = (obj.f_end - obj.f0)/n_ax;
            obj.f_ax = obj.f0:step:obj.f_end;
        end
        function WITD = Wave_generator(obj,phi0)
            % WITD means that "Wave in Time Domain".
            WITD = exp(1j*(obj.Wave_phi() + phi0));
        end
    end
    methods (Access = private)
        function phi_t = Wave_phi(obj)
            % Caculate the phase of signal based on time domain.
            n = 0:length(obj.f_ax)-1;
            phi_t = zeros(1,n(end)+1);
            Ts = 1/obj.fs;
            for i = 2:length(phi_t)
                phi_t(i) = mod(2*pi*Ts*trapz(n(1:i),obj.f_ax(1:i)),2*pi);
            end
        end
    end
    methods (Static)
        function [t,A] = Wave_reshape(array,fs,PRF,N)
            single_n = floor(fs/PRF);
            array_nec = array(1:N*single_n);
            t = 0:1/fs:1/PRF-1/fs;
            A = reshape(array_nec,single_n,[]);
        end
        function AR = Wave_receive(t,AT,fc,PRF,R0,vr,RCS)
            arguments
                t   (1,:)
                AT  (:,:)
                fc  (1,1)
                PRF (1,1)
                R0  (1,1)
                vr  (1,1)
                RCS (1,1) = 1 % Radar Cross Section
            end
            M = size(AT,2);
            fs = 1/(t(2) - t(1));
            AR = zeros(size(AT));
            N_label = R0*fc/1.5e8;
            for i = 1:M
                % ***************************************************
                % *The phase compensation is divided into two parts.*
                % *One is phase between pulses:                     *
                % *  exp(-1j*2*pi*(2/c)*(R0-(i-1)vr/PRF)*fs)        *
                % *Another is phase for quantidication error:       *
                % *  exp(1j*2*pi*(2/c)*(i-1)*vr/PRF*fc)             *
                % ***************************************************
                R = R0 - (i-1)*vr/PRF;
                td = R/1.5e8;
                N = ceil(td*fs);
                Nd = abs(N_label-N);
                % phi = (-Nd*fc/fs-td*fs)*2*pi;
                phi = (Nd*fc/fs-td*fc)*2*pi;
                AR(:,i) = RCS.*[zeros(N,1);AT(1:end-N,i)]*exp(1j*phi);
            end
            % AR = RCS*R0^(-4).*[zeros(N,M);AT(1:end-N,:)]*exp(1j*phi);
        end
        function A_PC = Wave_PC(AT,AR,tau,fs)
            % PC:Pulse Compression
            N = size(AT,2);
            M = size(AT,1);
            npulse = floor(tau*fs);
            % A_PC = zeros(2*M-1,N);
            A_PC = zeros(M,N);
            % cross-correlation in fast time dimension
            % for i =1:N
            %     A_PC(:,i) = xcorr(AT(:,i),AR(:,i));
            % end
            for i = 1:N
                X = fftshift(fft(AT(:,i),M));
                Y = fftshift(fft(AR(:,i),M));
                S = conj(X).*Y;
                s = ifft(S,M);
                A_PC(:,i) = s;
            end
            % for i = 1:N
            %     s = conv(AT(:,i),flipud(conj(AR(:,i))));
            %     A_PC(:,i) = s;
            % end
            % A_PC = flipud(A_PC(1:end-M+1,:));
            % A_PC = flipud(A_PC(1+npulse:M+npulse,:));
            % A_PC = flipud(A_PC);
        end
        function A_PD = Wave_PD(A_PC,fs,Nfft)
            % PD:Pulse Doppler
            N = size(A_PC,2);
            M = size(A_PC,1);
            A_PD = zeros(M,Nfft);
            % df = fs/Nfft;
            % window = hamming(N);
            window = 1;
            % FFT in slow time dimension
            for i = 1:M
                x = A_PC(i,:).*window';
                A_PD(i,:) = fftshift(fft(x,Nfft));
                A_PD(i,:) = A_PD(i,:)/Nfft;
            end

        end
    end
end

